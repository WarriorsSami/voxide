<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/models.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/models.rs" />
              <option name="originalContent" value="use serde::{Deserialize, Serialize};&#10;use sqlx::FromRow;&#10;&#10;/// KDF parameters for Argon2id&#10;#[derive(Debug, Clone, Serialize, Deserialize)]&#10;pub struct KdfParams {&#10;    pub algorithm: String,&#10;    pub version: String,&#10;    pub m_cost_kib: u32,&#10;    pub t_cost: u32,&#10;    pub p_cost: u32,&#10;    pub key_len: u32,&#10;}&#10;&#10;impl Default for KdfParams {&#10;    fn default() -&gt; Self {&#10;        Self {&#10;            algorithm: &quot;argon2id&quot;.to_string(),&#10;            version: &quot;0x13&quot;.to_string(),&#10;            m_cost_kib: 65536,&#10;            t_cost: 3,&#10;            p_cost: 1,&#10;            key_len: 32,&#10;        }&#10;    }&#10;}&#10;&#10;/// Metadata row (single row per vault)&#10;#[derive(Debug, FromRow)]&#10;pub struct Meta {&#10;    pub version: i64,&#10;    pub kdf_salt: Vec&lt;u8&gt;,&#10;    pub kdf_params: String,&#10;    pub created_at: String,&#10;    pub verifier_nonce: Vec&lt;u8&gt;,&#10;    pub verifier_ct: Vec&lt;u8&gt;,&#10;}&#10;&#10;impl Meta {&#10;    pub fn kdf_params_parse(&amp;self) -&gt; anyhow::Result&lt;KdfParams&gt; {&#10;        Ok(serde_json::from_str(&amp;self.kdf_params)?)&#10;    }&#10;}&#10;&#10;/// Entry row (one per service/username pair)&#10;#[derive(Debug, FromRow)]&#10;pub struct Entry {&#10;    pub id: String,  // UUID stored as TEXT&#10;    pub service: String,&#10;    pub username: String,&#10;    pub nonce: Vec&lt;u8&gt;,&#10;    pub ciphertext: Vec&lt;u8&gt;,&#10;    pub created_at: String,&#10;    pub updated_at: String,&#10;}&#10;&#10;/// New entry for insertion&#10;pub struct NewEntry {&#10;    pub service: String,&#10;    pub username: String,&#10;    pub nonce: Vec&lt;u8&gt;,&#10;    pub ciphertext: Vec&lt;u8&gt;,&#10;}&#10;&#10;/// Listing tuple for list command&#10;#[derive(Debug)]&#10;pub struct EntryPair {&#10;    pub service: String,&#10;    pub username: String,&#10;    pub created_at: String,&#10;}&#10;&#10;/// Encrypted payload structure&#10;#[derive(Debug, Serialize, Deserialize)]&#10;pub struct EntryPayload {&#10;    pub password: String,&#10;    #[serde(skip_serializing_if = &quot;Option::is_none&quot;)]&#10;    pub notes: Option&lt;String&gt;,&#10;}&#10;&#10;" />
              <option name="updatedContent" value="use serde::{Deserialize, Serialize};&#10;use sqlx::FromRow;&#10;&#10;/// KDF parameters for Argon2id&#10;#[derive(Debug, Clone, Serialize, Deserialize)]&#10;pub struct KdfParams {&#10;    pub algorithm: String,&#10;    pub version: String,&#10;    pub m_cost_kib: u32,&#10;    pub t_cost: u32,&#10;    pub p_cost: u32,&#10;    pub key_len: u32,&#10;}&#10;&#10;impl Default for KdfParams {&#10;    fn default() -&gt; Self {&#10;        Self {&#10;            algorithm: &quot;argon2id&quot;.to_string(),&#10;            version: &quot;0x13&quot;.to_string(),&#10;            m_cost_kib: 65536,&#10;            t_cost: 3,&#10;            p_cost: 1,&#10;            key_len: 32,&#10;        }&#10;    }&#10;}&#10;&#10;/// Metadata row (single row per vault)&#10;#[derive(Debug, FromRow)]&#10;pub struct Meta {&#10;    pub version: i64,&#10;    pub kdf_salt: Vec&lt;u8&gt;,&#10;    pub kdf_params: String,&#10;    pub created_at: String,&#10;    pub verifier_nonce: Vec&lt;u8&gt;,&#10;    pub verifier_ct: Vec&lt;u8&gt;,&#10;}&#10;&#10;impl Meta {&#10;    pub fn kdf_params_parse(&amp;self) -&gt; anyhow::Result&lt;KdfParams&gt; {&#10;        Ok(serde_json::from_str(&amp;self.kdf_params)?)&#10;    }&#10;}&#10;&#10;/// Entry row (one per service/username pair)&#10;#[derive(Debug, FromRow)]&#10;pub struct Entry {&#10;    pub id: String,  // UUID stored as TEXT&#10;    pub service: String,&#10;    pub username: String,&#10;    pub nonce: Vec&lt;u8&gt;,&#10;    pub ciphertext: Vec&lt;u8&gt;,&#10;    pub created_at: String,&#10;    pub updated_at: String,&#10;}&#10;&#10;/// New entry for insertion&#10;pub struct NewEntry {&#10;    pub service: String,&#10;    pub username: String,&#10;    pub nonce: Vec&lt;u8&gt;,&#10;    pub ciphertext: Vec&lt;u8&gt;,&#10;}&#10;&#10;/// Listing tuple for list command&#10;#[derive(Debug)]&#10;pub struct EntryPair {&#10;    pub service: String,&#10;    pub username: String,&#10;    pub created_at: String,&#10;}&#10;&#10;/// Encrypted payload structure&#10;#[derive(Debug, Serialize, Deserialize)]&#10;pub struct EntryPayload {&#10;    pub password: String,&#10;    #[serde(skip_serializing_if = &quot;Option::is_none&quot;)]&#10;    pub notes: Option&lt;String&gt;,&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/vault.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/vault.rs" />
              <option name="originalContent" value="use anyhow::{anyhow, Result};&#10;use secrecy::{SecretBox, SecretString};&#10;use sqlx::{Pool, Sqlite};&#10;use std::fs;&#10;use std::io::Write;&#10;use zeroize::Zeroizing;&#10;&#10;use crate::crypto::{ad_for, create_verifier, derive_key, generate_nonce, generate_salt, open, seal, verify_key};&#10;use crate::db::{create_pool, ensure_schema, EntryRepo, MetaRepo};&#10;use crate::dto::*;&#10;use crate::models::{EntryPayload, KdfParams, NewEntry};&#10;&#10;/// VaultService handles all vault operations&#10;pub struct VaultService {&#10;    pool: Pool&lt;Sqlite&gt;,&#10;}&#10;&#10;impl VaultService {&#10;    /// Open an existing vault or create a new connection&#10;    pub async fn open(vault_path: &amp;str) -&gt; Result&lt;Self&gt; {&#10;        let pool = create_pool(vault_path).await?;&#10;        Ok(Self { pool })&#10;    }&#10;&#10;    /// Initialize a new vault with master password&#10;    pub async fn init(&amp;self, dto: InitVaultDto) -&gt; Result&lt;()&gt; {&#10;        // Ensure schema exists&#10;        ensure_schema(&amp;self.pool).await?;&#10;&#10;        // Check if vault is already initialized&#10;        if MetaRepo::get(&amp;self.pool).await?.is_some() {&#10;            anyhow::bail!(&quot;Vault is already initialized&quot;);&#10;        }&#10;&#10;        // Generate salt and derive key&#10;        let salt = generate_salt();&#10;        let params = KdfParams::default();&#10;        let key = derive_key(&amp;dto.master_password, &amp;salt, &amp;params)?;&#10;&#10;        // Create verifier&#10;        let (verifier_nonce, verifier_ct) = create_verifier(&amp;key)?;&#10;&#10;        // Store metadata&#10;        let kdf_params_json = serde_json::to_string(&amp;params)?;&#10;&#10;        let metadata = InitMetaDto {&#10;            version: 1,&#10;            kdf_salt: salt.to_vec(),&#10;            kdf_params: kdf_params_json,&#10;            verifier_nonce,&#10;            verifier_ct,&#10;        };&#10;&#10;        MetaRepo::insert(&#10;            &amp;self.pool,&#10;            metadata&#10;        )&#10;        .await?;&#10;&#10;        println!(&quot;✓ Vault initialized successfully&quot;);&#10;        Ok(())&#10;    }&#10;&#10;    /// Verify master password without returning the key (public unlock guard)&#10;    pub async fn verify_unlock(&amp;self, master_password: &amp;SecretString) -&gt; Result&lt;()&gt; {&#10;        let _key = self.unlock(master_password).await?;&#10;        Ok(())&#10;    }&#10;&#10;    /// Unlock vault and return derived key (private helper)&#10;    async fn unlock(&amp;self, master_password: &amp;SecretString) -&gt; Result&lt;SecretBox&lt;[u8; 32]&gt;&gt; {&#10;        let meta = MetaRepo::get(&amp;self.pool)&#10;            .await?&#10;            .ok_or_else(|| anyhow!(&quot;Vault not initialized&quot;))?;&#10;&#10;        let params = meta.kdf_params_parse()?;&#10;        let key = derive_key(master_password, &amp;meta.kdf_salt, &amp;params)?;&#10;&#10;        // Verify the key&#10;        verify_key(&amp;key, &amp;meta.verifier_nonce, &amp;meta.verifier_ct)?;&#10;&#10;        Ok(key)&#10;    }&#10;&#10;    /// Add a new entry to the vault&#10;    pub async fn add(&amp;self, dto: AddEntryDto) -&gt; Result&lt;()&gt; {&#10;        // Unlock vault&#10;        let key = self.unlock(&amp;dto.master_password).await?;&#10;&#10;        // Check if entry already exists&#10;        if EntryRepo::by_pair(&amp;self.pool, dto.service.as_ref(), dto.username.as_ref())&#10;            .await?&#10;            .is_some()&#10;        {&#10;            anyhow::bail!(&quot;Entry already exists for {}/{}&quot;, dto.service, dto.username);&#10;        }&#10;&#10;        // Create payload&#10;        let payload = EntryPayload {&#10;            password: dto.password.into_inner(),&#10;            notes: dto.notes.map(|n| n.into_inner())&#10;        };&#10;        let payload_json = Zeroizing::new(serde_json::to_vec(&amp;payload)?);&#10;&#10;        // Generate nonce and AD&#10;        let nonce = generate_nonce();&#10;        let ad = ad_for(dto.service.as_ref(), dto.username.as_ref());&#10;&#10;        // Encrypt&#10;        let ciphertext = seal(&amp;key, &amp;nonce, &amp;payload_json, &amp;ad)?;&#10;&#10;        // Insert entry&#10;        let new_entry = NewEntry {&#10;            service: dto.service.as_ref().to_string(),&#10;            username: dto.username.as_ref().to_string(),&#10;            nonce: nonce.to_vec(),&#10;            ciphertext,&#10;        };&#10;&#10;        EntryRepo::insert(&amp;self.pool, new_entry).await?;&#10;&#10;        println!(&quot;✓ Added entry for {}/{}&quot;, dto.service, dto.username);&#10;        Ok(())&#10;    }&#10;&#10;    /// Get an entry from the vault&#10;    pub async fn get(&amp;self, dto: GetEntryDto) -&gt; Result&lt;EntryPayloadDto&gt; {&#10;        // Unlock vault&#10;        let key = self.unlock(&amp;dto.master_password).await?;&#10;&#10;        // Fetch entry&#10;        let entry = EntryRepo::by_pair(&amp;self.pool, dto.service.as_ref(), dto.username.as_ref())&#10;            .await?&#10;            .ok_or_else(|| anyhow!(&quot;Entry not found&quot;))?;&#10;&#10;        // Prepare nonce and AD&#10;        if entry.nonce.len() != 24 {&#10;            anyhow::bail!(&quot;Invalid nonce length&quot;);&#10;        }&#10;        let nonce: [u8; 24] = entry.nonce.try_into().unwrap();&#10;        let ad = ad_for(dto.service.as_ref(), dto.username.as_ref());&#10;&#10;        // Decrypt&#10;        let plaintext = open(&amp;key, &amp;nonce, &amp;entry.ciphertext, &amp;ad)?;&#10;&#10;        // Parse payload&#10;        let payload: EntryPayload = serde_json::from_slice(&amp;plaintext)?;&#10;&#10;        Ok(payload.into())&#10;    }&#10;&#10;    /// List all entries (service/username pairs only)&#10;    pub async fn list(&amp;self) -&gt; Result&lt;Vec&lt;EntryListItemDto&gt;&gt; {&#10;        let pairs = EntryRepo::list_pairs(&amp;self.pool).await?;&#10;        Ok(pairs&#10;            .into_iter()&#10;            .map(|p| EntryListItemDto {&#10;                service: p.service,&#10;                username: p.username,&#10;                created_at: p.created_at,&#10;            })&#10;            .collect())&#10;    }&#10;&#10;    /// Delete an entry from the vault&#10;    pub async fn delete(&amp;self, dto: DeleteEntryDto) -&gt; Result&lt;()&gt; {&#10;        let rows_affected = EntryRepo::delete(&amp;self.pool, dto.service.as_ref(), dto.username.as_ref()).await?;&#10;&#10;        if rows_affected == 0 {&#10;            return Err(anyhow!(&quot;Entry not found&quot;));&#10;        }&#10;&#10;        println!(&quot;✓ Deleted entry for {}/{}&quot;, dto.service, dto.username);&#10;        Ok(())&#10;    }&#10;&#10;    /// Change master password (re-encrypt all entries)&#10;    pub async fn change_master(&amp;self, dto: ChangeMasterDto) -&gt; Result&lt;()&gt; {&#10;        // Unlock with old password&#10;        let old_key = self.unlock(&amp;dto.old_password).await?;&#10;&#10;        // Generate new salt and derive new key&#10;        let new_salt = generate_salt();&#10;        let params = KdfParams::default();&#10;        let new_key = derive_key(&amp;dto.new_password, &amp;new_salt, &amp;params)?;&#10;&#10;        // Create new verifier&#10;        let (new_verifier_nonce, new_verifier_ct) = create_verifier(&amp;new_key)?;&#10;&#10;        // Fetch all entries&#10;        let entries = EntryRepo::list_all(&amp;self.pool).await?;&#10;&#10;        // Create temporary database&#10;        let temp_path = format!(&quot;{}.tmp&quot;, dto.vault_path);&#10;        let temp_pool = create_pool(&amp;temp_path).await?;&#10;        ensure_schema(&amp;temp_pool).await?;&#10;&#10;        // Insert new metadata&#10;        let kdf_params_json = serde_json::to_string(&amp;params)?;&#10;&#10;        let metadata = InitMetaDto {&#10;            version: 1,&#10;            kdf_salt: new_salt.to_vec(),&#10;            kdf_params: kdf_params_json,&#10;            verifier_nonce: new_verifier_nonce,&#10;            verifier_ct: new_verifier_ct,&#10;        };&#10;&#10;        MetaRepo::insert(&#10;            &amp;temp_pool,&#10;            metadata&#10;        )&#10;        .await?;&#10;&#10;        // Re-encrypt and insert all entries&#10;        for entry in entries {&#10;            // Decrypt with old key&#10;            let nonce: [u8; 24] = entry&#10;                .nonce&#10;                .clone()&#10;                .try_into()&#10;                .map_err(|_| anyhow!(&quot;Invalid nonce&quot;))?;&#10;            let ad = ad_for(&amp;entry.service, &amp;entry.username);&#10;            let plaintext = open(&amp;old_key, &amp;nonce, &amp;entry.ciphertext, &amp;ad)?;&#10;&#10;            // Encrypt with new key&#10;            let new_nonce = generate_nonce();&#10;            let new_ciphertext = seal(&amp;new_key, &amp;new_nonce, &amp;plaintext, &amp;ad)?;&#10;&#10;            // Insert into temp database&#10;            let new_entry = NewEntry {&#10;                service: entry.service,&#10;                username: entry.username,&#10;                nonce: new_nonce.to_vec(),&#10;                ciphertext: new_ciphertext,&#10;            };&#10;            EntryRepo::insert(&amp;temp_pool, new_entry).await?;&#10;        }&#10;&#10;        // Close pools&#10;        temp_pool.close().await;&#10;        self.pool.close().await;&#10;&#10;        // Atomic rename&#10;        fs::rename(&amp;temp_path, &amp;dto.vault_path)?;&#10;&#10;        println!(&quot;✓ Master password changed successfully&quot;);&#10;        println!(&quot;  Please reconnect to the vault&quot;);&#10;        Ok(())&#10;    }&#10;&#10;    /// Export vault to encrypted JSON bundle&#10;    pub async fn export(&amp;self, dto: ExportVaultDto) -&gt; Result&lt;()&gt; {&#10;        // Unlock vault (verify password)&#10;        let _key = self.unlock(&amp;dto.master_password).await?;&#10;&#10;        // Fetch metadata&#10;        let meta = MetaRepo::get(&amp;self.pool)&#10;            .await?&#10;            .ok_or_else(|| anyhow!(&quot;Vault not initialized&quot;))?;&#10;&#10;        // Fetch all entries&#10;        let entries = EntryRepo::list_all(&amp;self.pool).await?;&#10;&#10;        // Build export DTO&#10;        let export_data = ExportedVaultDto::from_vault_data(&amp;meta, &amp;entries);&#10;&#10;        // Serialize to JSON and write to file&#10;        let json_str = serde_json::to_string_pretty(&amp;export_data)?;&#10;        let mut file = fs::File::create(&amp;dto.export_path)?;&#10;        file.write_all(json_str.as_bytes())?;&#10;&#10;        println!(&quot;✓ Exported {} entries to {}&quot;, entries.len(), dto.export_path);&#10;        Ok(())&#10;    }&#10;&#10;    /// Import vault from encrypted JSON bundle&#10;    pub async fn import(&amp;self, dto: ImportVaultDto) -&gt; Result&lt;()&gt; {&#10;        // Ensure schema exists&#10;        ensure_schema(&amp;self.pool).await?;&#10;&#10;        // Check if vault is already initialized&#10;        if MetaRepo::get(&amp;self.pool).await?.is_some() {&#10;            return Err(anyhow!(&quot;Vault is already initialized. Use a new vault file for import.&quot;));&#10;        }&#10;&#10;        // Read and deserialize import file&#10;        let json_str = fs::read_to_string(&amp;dto.import_path)?;&#10;        let import_data: ExportedVaultDto = serde_json::from_str(&amp;json_str)?;&#10;&#10;        // Decode and insert metadata&#10;        let metadata = import_data.decode_metadata()?;&#10;        MetaRepo::insert(&amp;self.pool, metadata).await?;&#10;&#10;        // Verify the password works&#10;        let _key = self.unlock(&amp;dto.master_password).await?;&#10;&#10;        // Import entries&#10;        for entry_dto in &amp;import_data.entries {&#10;            let (nonce, ciphertext) = entry_dto.decode_for_db()?;&#10;&#10;            let new_entry = NewEntry {&#10;                service: entry_dto.service.clone(),&#10;                username: entry_dto.username.clone(),&#10;                nonce,&#10;                ciphertext,&#10;            };&#10;            EntryRepo::insert(&amp;self.pool, new_entry).await?;&#10;        }&#10;&#10;        println!(&quot;✓ Imported {} entries from {}&quot;, import_data.entries.len(), dto.import_path);&#10;        Ok(())&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="use anyhow::{anyhow, Result};&#10;use secrecy::{SecretBox, SecretString};&#10;use sqlx::{Pool, Sqlite};&#10;use std::fs;&#10;use std::io::Write;&#10;use zeroize::Zeroizing;&#10;&#10;use crate::crypto::{ad_for, create_verifier, derive_key, generate_nonce, generate_salt, open, seal, verify_key};&#10;use crate::db::{create_pool, ensure_schema, EntryRepo, MetaRepo};&#10;use crate::dto::*;&#10;use crate::models::{EntryPayload, KdfParams, NewEntry};&#10;&#10;/// VaultService handles all vault operations&#10;pub struct VaultService {&#10;    pool: Pool&lt;Sqlite&gt;,&#10;}&#10;&#10;impl VaultService {&#10;    /// Open an existing vault or create a new connection&#10;    pub async fn open(vault_path: &amp;str) -&gt; Result&lt;Self&gt; {&#10;        let pool = create_pool(vault_path).await?;&#10;        Ok(Self { pool })&#10;    }&#10;&#10;    /// Initialize a new vault with master password&#10;    pub async fn init(&amp;self, dto: InitVaultDto) -&gt; Result&lt;()&gt; {&#10;        // Ensure schema exists&#10;        ensure_schema(&amp;self.pool).await?;&#10;&#10;        // Check if vault is already initialized&#10;        if MetaRepo::get(&amp;self.pool).await?.is_some() {&#10;            anyhow::bail!(&quot;Vault is already initialized&quot;);&#10;        }&#10;&#10;        // Generate salt and derive key&#10;        let salt = generate_salt();&#10;        let params = KdfParams::default();&#10;        let key = derive_key(&amp;dto.master_password, &amp;salt, &amp;params)?;&#10;&#10;        // Create verifier&#10;        let (verifier_nonce, verifier_ct) = create_verifier(&amp;key)?;&#10;&#10;        // Store metadata&#10;        let kdf_params_json = serde_json::to_string(&amp;params)?;&#10;&#10;        let metadata = InitMetaDto {&#10;            version: 1,&#10;            kdf_salt: salt.to_vec(),&#10;            kdf_params: kdf_params_json,&#10;            verifier_nonce,&#10;            verifier_ct,&#10;        };&#10;&#10;        MetaRepo::insert(&#10;            &amp;self.pool,&#10;            metadata&#10;        )&#10;        .await?;&#10;&#10;        println!(&quot;✓ Vault initialized successfully&quot;);&#10;        Ok(())&#10;    }&#10;&#10;    /// Verify master password without returning the key (public unlock guard)&#10;    pub async fn verify_unlock(&amp;self, master_password: &amp;SecretString) -&gt; Result&lt;()&gt; {&#10;        let _key = self.unlock(master_password).await?;&#10;        Ok(())&#10;    }&#10;&#10;    /// Unlock vault and return derived key (private helper)&#10;    async fn unlock(&amp;self, master_password: &amp;SecretString) -&gt; Result&lt;SecretBox&lt;[u8; 32]&gt;&gt; {&#10;        let meta = MetaRepo::get(&amp;self.pool)&#10;            .await?&#10;            .ok_or_else(|| anyhow!(&quot;Vault not initialized&quot;))?;&#10;&#10;        let params = meta.kdf_params_parse()?;&#10;        let key = derive_key(master_password, &amp;meta.kdf_salt, &amp;params)?;&#10;&#10;        // Verify the key&#10;        verify_key(&amp;key, &amp;meta.verifier_nonce, &amp;meta.verifier_ct)?;&#10;&#10;        Ok(key)&#10;    }&#10;&#10;    /// Add a new entry to the vault&#10;    pub async fn add(&amp;self, dto: AddEntryDto) -&gt; Result&lt;()&gt; {&#10;        // Unlock vault&#10;        let key = self.unlock(&amp;dto.master_password).await?;&#10;&#10;        // Check if entry already exists&#10;        if EntryRepo::by_pair(&amp;self.pool, dto.service.as_ref(), dto.username.as_ref())&#10;            .await?&#10;            .is_some()&#10;        {&#10;            anyhow::bail!(&quot;Entry already exists for {}/{}&quot;, dto.service, dto.username);&#10;        }&#10;&#10;        // Create payload&#10;        let payload = EntryPayload {&#10;            password: dto.password.into_inner(),&#10;            notes: dto.notes.map(|n| n.into_inner())&#10;        };&#10;        let payload_json = Zeroizing::new(serde_json::to_vec(&amp;payload)?);&#10;&#10;        // Generate nonce and AD&#10;        let nonce = generate_nonce();&#10;        let ad = ad_for(dto.service.as_ref(), dto.username.as_ref());&#10;&#10;        // Encrypt&#10;        let ciphertext = seal(&amp;key, &amp;nonce, &amp;payload_json, &amp;ad)?;&#10;&#10;        // Insert entry&#10;        let new_entry = NewEntry {&#10;            service: dto.service.as_ref().to_string(),&#10;            username: dto.username.as_ref().to_string(),&#10;            nonce: nonce.to_vec(),&#10;            ciphertext,&#10;        };&#10;&#10;        EntryRepo::insert(&amp;self.pool, new_entry).await?;&#10;&#10;        println!(&quot;✓ Added entry for {}/{}&quot;, dto.service, dto.username);&#10;        Ok(())&#10;    }&#10;&#10;    /// Get an entry from the vault&#10;    pub async fn get(&amp;self, dto: GetEntryDto) -&gt; Result&lt;EntryPayloadDto&gt; {&#10;        // Unlock vault&#10;        let key = self.unlock(&amp;dto.master_password).await?;&#10;&#10;        // Fetch entry&#10;        let entry = EntryRepo::by_pair(&amp;self.pool, dto.service.as_ref(), dto.username.as_ref())&#10;            .await?&#10;            .ok_or_else(|| anyhow!(&quot;Entry not found&quot;))?;&#10;&#10;        // Prepare nonce and AD&#10;        if entry.nonce.len() != 24 {&#10;            anyhow::bail!(&quot;Invalid nonce length&quot;);&#10;        }&#10;        let nonce: [u8; 24] = entry.nonce.try_into().unwrap();&#10;        let ad = ad_for(dto.service.as_ref(), dto.username.as_ref());&#10;&#10;        // Decrypt&#10;        let plaintext = open(&amp;key, &amp;nonce, &amp;entry.ciphertext, &amp;ad)?;&#10;&#10;        // Parse payload&#10;        let payload: EntryPayload = serde_json::from_slice(&amp;plaintext)?;&#10;&#10;        Ok(payload.into())&#10;    }&#10;&#10;    /// List all entries (service/username pairs only)&#10;    pub async fn list(&amp;self) -&gt; Result&lt;Vec&lt;EntryListItemDto&gt;&gt; {&#10;        let pairs = EntryRepo::list_pairs(&amp;self.pool).await?;&#10;        Ok(pairs&#10;            .into_iter()&#10;            .map(|p| EntryListItemDto {&#10;                service: p.service,&#10;                username: p.username,&#10;                created_at: p.created_at,&#10;            })&#10;            .collect())&#10;    }&#10;&#10;    /// Delete an entry from the vault&#10;    pub async fn delete(&amp;self, dto: DeleteEntryDto) -&gt; Result&lt;()&gt; {&#10;        let rows_affected = EntryRepo::delete(&amp;self.pool, dto.service.as_ref(), dto.username.as_ref()).await?;&#10;&#10;        if rows_affected == 0 {&#10;            return Err(anyhow!(&quot;Entry not found&quot;));&#10;        }&#10;&#10;        println!(&quot;✓ Deleted entry for {}/{}&quot;, dto.service, dto.username);&#10;        Ok(())&#10;    }&#10;&#10;    /// Change master password (re-encrypt all entries)&#10;    pub async fn change_master(&amp;self, dto: ChangeMasterDto) -&gt; Result&lt;()&gt; {&#10;        // Unlock with old password&#10;        let old_key = self.unlock(&amp;dto.old_password).await?;&#10;&#10;        // Generate new salt and derive new key&#10;        let new_salt = generate_salt();&#10;        let params = KdfParams::default();&#10;        let new_key = derive_key(&amp;dto.new_password, &amp;new_salt, &amp;params)?;&#10;&#10;        // Create new verifier&#10;        let (new_verifier_nonce, new_verifier_ct) = create_verifier(&amp;new_key)?;&#10;&#10;        // Fetch all entries&#10;        let entries = EntryRepo::list_all(&amp;self.pool).await?;&#10;&#10;        // Create temporary database&#10;        let temp_path = format!(&quot;{}.tmp&quot;, dto.vault_path);&#10;        let temp_pool = create_pool(&amp;temp_path).await?;&#10;        ensure_schema(&amp;temp_pool).await?;&#10;&#10;        // Insert new metadata&#10;        let kdf_params_json = serde_json::to_string(&amp;params)?;&#10;&#10;        let metadata = InitMetaDto {&#10;            version: 1,&#10;            kdf_salt: new_salt.to_vec(),&#10;            kdf_params: kdf_params_json,&#10;            verifier_nonce: new_verifier_nonce,&#10;            verifier_ct: new_verifier_ct,&#10;        };&#10;&#10;        MetaRepo::insert(&#10;            &amp;temp_pool,&#10;            metadata&#10;        )&#10;        .await?;&#10;&#10;        // Re-encrypt and insert all entries&#10;        for entry in entries {&#10;            // Decrypt with old key&#10;            let nonce: [u8; 24] = entry&#10;                .nonce&#10;                .clone()&#10;                .try_into()&#10;                .map_err(|_| anyhow!(&quot;Invalid nonce&quot;))?;&#10;            let ad = ad_for(&amp;entry.service, &amp;entry.username);&#10;            let plaintext = open(&amp;old_key, &amp;nonce, &amp;entry.ciphertext, &amp;ad)?;&#10;&#10;            // Encrypt with new key&#10;            let new_nonce = generate_nonce();&#10;            let new_ciphertext = seal(&amp;new_key, &amp;new_nonce, &amp;plaintext, &amp;ad)?;&#10;&#10;            // Insert into temp database&#10;            let new_entry = NewEntry {&#10;                service: entry.service,&#10;                username: entry.username,&#10;                nonce: new_nonce.to_vec(),&#10;                ciphertext: new_ciphertext,&#10;            };&#10;            EntryRepo::insert(&amp;temp_pool, new_entry).await?;&#10;        }&#10;&#10;        // Close pools&#10;        temp_pool.close().await;&#10;        self.pool.close().await;&#10;&#10;        // Atomic rename&#10;        fs::rename(&amp;temp_path, &amp;dto.vault_path)?;&#10;&#10;        println!(&quot;✓ Master password changed successfully&quot;);&#10;        println!(&quot;  Please reconnect to the vault&quot;);&#10;        Ok(())&#10;    }&#10;&#10;    /// Export vault to encrypted JSON bundle&#10;    pub async fn export(&amp;self, dto: ExportVaultDto) -&gt; Result&lt;()&gt; {&#10;        // Unlock vault (verify password)&#10;        let _key = self.unlock(&amp;dto.master_password).await?;&#10;&#10;        // Fetch metadata&#10;        let meta = MetaRepo::get(&amp;self.pool)&#10;            .await?&#10;            .ok_or_else(|| anyhow!(&quot;Vault not initialized&quot;))?;&#10;&#10;        // Fetch all entries&#10;        let entries = EntryRepo::list_all(&amp;self.pool).await?;&#10;&#10;        // Build export DTO&#10;        let export_data = ExportedVaultDto::from_vault_data(&amp;meta, &amp;entries);&#10;&#10;        // Serialize to JSON and write to file&#10;        let json_str = serde_json::to_string_pretty(&amp;export_data)?;&#10;        let mut file = fs::File::create(&amp;dto.export_path)?;&#10;        file.write_all(json_str.as_bytes())?;&#10;&#10;        println!(&quot;✓ Exported {} entries to {}&quot;, entries.len(), dto.export_path);&#10;        Ok(())&#10;    }&#10;&#10;    /// Import vault from encrypted JSON bundle&#10;    pub async fn import(&amp;self, dto: ImportVaultDto) -&gt; Result&lt;()&gt; {&#10;        // Ensure schema exists&#10;        ensure_schema(&amp;self.pool).await?;&#10;&#10;        // Check if vault is already initialized&#10;        if MetaRepo::get(&amp;self.pool).await?.is_some() {&#10;            return Err(anyhow!(&quot;Vault is already initialized. Use a new vault file for import.&quot;));&#10;        }&#10;&#10;        // Read and deserialize import file&#10;        let json_str = fs::read_to_string(&amp;dto.import_path)?;&#10;        let import_data: ExportedVaultDto = serde_json::from_str(&amp;json_str)?;&#10;&#10;        // Decode and insert metadata&#10;        let metadata = import_data.decode_metadata()?;&#10;        MetaRepo::insert(&amp;self.pool, metadata).await?;&#10;&#10;        // Verify the password works&#10;        let _key = self.unlock(&amp;dto.master_password).await?;&#10;&#10;        // Import entries&#10;        for entry_dto in &amp;import_data.entries {&#10;            let (nonce, ciphertext) = entry_dto.decode_for_db()?;&#10;&#10;            let new_entry = NewEntry {&#10;                service: entry_dto.service.clone(),&#10;                username: entry_dto.username.clone(),&#10;                nonce,&#10;                ciphertext,&#10;            };&#10;            EntryRepo::insert(&amp;self.pool, new_entry).await?;&#10;        }&#10;&#10;        println!(&quot;✓ Imported {} entries from {}&quot;, import_data.entries.len(), dto.import_path);&#10;        Ok(())&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>